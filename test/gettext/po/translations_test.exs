defmodule Gettext.PO.TranslationsTest do
  use ExUnit.Case, async: true

  doctest Gettext.PO.Translations

  alias Gettext.PO.{
    Translations,
    Translation,
    ParticularTranslation,
    PluralTranslation,
    ParticularPluralTranslation
  }

  @autogenerated_flags MapSet.new(["elixir-format"])

  test "autogenerated?/1: singular translations" do
    assert Translations.autogenerated?(%Translation{flags: @autogenerated_flags})
    refute Translations.autogenerated?(%Translation{})
  end

  test "autogenerated?/1: particular singular translations" do
    assert Translations.autogenerated?(%ParticularTranslation{flags: @autogenerated_flags})
    refute Translations.autogenerated?(%ParticularTranslation{})
  end

  test "autogenerated?/1: plural translations" do
    assert Translations.autogenerated?(%PluralTranslation{flags: @autogenerated_flags})
    refute Translations.autogenerated?(%PluralTranslation{})
  end

  test "autogenerated?/1: particular plural translations" do
    assert Translations.autogenerated?(%ParticularPluralTranslation{flags: @autogenerated_flags})
    refute Translations.autogenerated?(%ParticularPluralTranslation{})
  end

  test "same?/2: singular translations" do
    t1 = %Translation{msgid: "foo", msgstr: "a"}
    t2 = %Translation{msgid: "foo", msgstr: "b"}
    assert Translations.same?(t1, t2)

    refute Translations.same?(%Translation{msgid: "a"}, %Translation{msgid: "b"})
  end

  test "same?/2: particular singular translations" do
    t1 = %ParticularTranslation{msgctxt: "bar", msgid: "foo", msgstr: "a"}
    t2 = %ParticularTranslation{msgctxt: "bar", msgid: "foo", msgstr: "b"}
    assert Translations.same?(t1, t2)

    refute Translations.same?(
             %ParticularTranslation{msgctxt: "foo", msgid: "a"},
             %ParticularTranslation{msgctxt: "foo", msgid: "b"}
           )
  end

  test "same?/2: plural translations" do
    assert Translations.same?(
             %PluralTranslation{msgid: "foo", msgid_plural: "bar", references: [{"foo.ex", 1}]},
             %PluralTranslation{msgid: "foo", msgid_plural: "bar"}
           )

    refute Translations.same?(
             %PluralTranslation{msgid: "a", msgid_plural: "foo"},
             %PluralTranslation{msgid: "b", msgid_plural: "foo"}
           )

    refute Translations.same?(
             %PluralTranslation{msgid: "foo", msgid_plural: "a"},
             %PluralTranslation{msgid: "foo", msgid_plural: "b"}
           )
  end

  test "same?/2: particular plural translations" do
    assert Translations.same?(
             %ParticularPluralTranslation{
               msgctxt: "a",
               msgid: "foo",
               msgid_plural: "bar",
               references: [{"foo.ex", 1}]
             },
             %ParticularPluralTranslation{msgctxt: "a", msgid: "foo", msgid_plural: "bar"}
           )

    refute Translations.same?(
             %ParticularPluralTranslation{msgctxt: "foo", msgid: "foo", msgid_plural: "a"},
             %ParticularPluralTranslation{msgctxt: "bar", msgid: "foo", msgid_plural: "a"}
           )

    refute Translations.same?(
             %ParticularPluralTranslation{msgctxt: "foo", msgid: "a", msgid_plural: "foo"},
             %ParticularPluralTranslation{msgctxt: "foo", msgid: "b", msgid_plural: "foo"}
           )

    refute Translations.same?(
             %ParticularPluralTranslation{msgctxt: "bar", msgid: "foo", msgid_plural: "a"},
             %ParticularPluralTranslation{msgctxt: "bar", msgid: "foo", msgid_plural: "b"}
           )
  end

  test "same?/2: mixed singular and plural translations (always different)" do
    refute Translations.same?(%Translation{msgid: "a"}, %PluralTranslation{
             msgid: "a",
             msgid_plural: "as"
           })
  end

  test "same?/2: mixed regular singular and particular translations (always different)" do
    refute Translations.same?(%Translation{msgid: "a"}, %ParticularTranslation{
             msgctxt: "foo",
             msgid: "a"
           })
  end

  test "same?/2: ignores if msgids are split as long as they're equal when concatenated" do
    assert Translations.same?(%Translation{msgid: ["foo", " bar"]}, %Translation{
             msgid: ["foo ", "bar"]
           })

    assert Translations.same?(
             %PluralTranslation{msgid: ["ab", "c"], msgid_plural: ["de", "f"]},
             %PluralTranslation{msgid: ["a", "bc"], msgid_plural: ["d", "ef"]}
           )
  end

  test "key/1: returns a {:regular, msgid} tuple for regular translations" do
    t = %Translation{msgid: ["foo"], msgstr: ["bar"], references: [{"foo.ex", 1}]}
    assert Translations.key(t) == {:regular, "foo"}
  end

  test "key/1: returns a {:particular, msgctxt msgid} tuple for particular regular translations" do
    t = %ParticularTranslation{
      msgctxt: ["foo"],
      msgid: ["bar"],
      msgstr: ["baz"],
      references: [{"foo.ex", 1}]
    }

    assert Translations.key(t) == {:particular, "foo", "bar"}
  end

  test "key/1: returns a {:plural, msgid, msgid_plural} tuple for plural translations" do
    t = %PluralTranslation{
      msgid: ["foo"],
      msgid_plural: ["foos"],
      msgstr: %{0 => [""], 1 => [""]}
    }

    assert Translations.key(t) == {:plural, "foo", "foos"}
  end

  test "key/1: returns a {:particular_plural, msgctxt msgid, msgid_plural} tuple for particular plural translations" do
    t = %ParticularPluralTranslation{
      msgctxt: ["bar"],
      msgid: ["foo"],
      msgid_plural: ["foos"],
      msgstr: %{0 => [""], 1 => [""]}
    }

    assert Translations.key(t) == {:particular_plural, "bar", "foo", "foos"}
  end

  test "mark_as_fuzzy/1" do
    t = Translations.mark_as_fuzzy(%Translation{})
    assert MapSet.member?(t.flags, "fuzzy")

    t = Translations.mark_as_fuzzy(%PluralTranslation{})
    assert MapSet.member?(t.flags, "fuzzy")
  end
end
